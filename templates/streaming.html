<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Streaming Response</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            white-space: pre-wrap;
            line-height: 1.5;
            margin: 0;
            overflow-x: hidden;
        }
        
        .italic {
            color: #888;
            font-style: italic;
        }
        #content {
            display: inline-block;
            position: relative;
            min-height: 1em;
        }
        .char {
            display: inline;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        .cursor {
            display: inline-block;
            width: 8px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s infinite;
            position: absolute;
            bottom: 0;
            margin-left: 2px;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .status {
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }
        
        .content {
            margin-top: 10px;
        }
        
        .status.complete {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="content"></div>
    <div id="cursor" class="cursor"></div>
    <div id="status" class="status">Loading response...</div>
    
    <script>
        const contentDiv = document.getElementById('content');
        const cursor = document.getElementById('cursor');
        const statusDiv = document.getElementById('status');
        
        let lastContent = '';
        let isTyping = false;
        let typeQueue = [];
        let isComplete = false;
        let checkInterval;
        let hasProcessedPrompt = false;

        // Function to update status
        function updateStatus(message) {
            statusDiv.textContent = message;
            console.log(`Status: ${message}`);
        }

        // Function to type characters one by one
        function typeCharacter() {
            if (typeQueue.length === 0) {
                isTyping = false;
                positionCursor();
                return;
            }
            
            const char = typeQueue.shift();
            const span = document.createElement('span');
            span.className = 'char';
            span.textContent = char;
            contentDiv.appendChild(span);
            
            // Position cursor after the last character
            positionCursor();
            
            // Schedule next character
            setTimeout(typeCharacter, Math.random() * 20 + 10); // Random delay between 10-30ms
        }
        
        // Position the cursor at the end of the content
        function positionCursor() {
            const range = document.createRange();
            const sel = window.getSelection();
            
            // Create a temporary text node for cursor positioning
            const tempNode = document.createTextNode('');
            contentDiv.appendChild(tempNode);
            
            range.setStart(tempNode, 0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            
            const rects = range.getClientRects();
            if (rects.length > 0) {
                const lastRect = rects[0];
                cursor.style.left = `${lastRect.right}px`;
                cursor.style.top = `${lastRect.top}px`;
            }
            
            // Remove the temporary node
            contentDiv.removeChild(tempNode);
            
            // Scroll into view
            cursor.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
        }

        // Process content and apply styling
        function processContent(text) {
            // Check for completion marker
            if (text.includes('[STREAM_COMPLETE]')) {
                isComplete = true;
                clearInterval(checkInterval);
                statusDiv.textContent = 'Generation complete';
                statusDiv.className = 'status complete';
                text = text.split('[STREAM_COMPLETE]')[0];
            }
            
            // Replace styling markers with appropriate HTML
            return text
                .replace(/\[italic\](.*?)\[\/italic\]/gs, '<span class="italic">$1</span>')
                .replace(/\[bold\](.*?)\[\/bold\]/gs, '<strong>$1</strong>')
                .replace(/\[code\](.*?)\[\/code\]/gs, '<code>$1</code>');
        }
        
        // Load initial content immediately
        async function loadInitialContent() {
            const txtUrl = window.location.href.replace(/\.html$/, '.txt') + '?t=' + Date.now();
            
            try {
                const response = await fetch(txtUrl, { 
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    updateStatus('Waiting for response to start...');
                    return false;
                }
                
                const text = await response.text();
                
                if (text) {
                    // Process the content to handle markers
                    const processedText = processContent(text);
                    
                    // Display existing content immediately
                    contentDiv.textContent = processedText;
                    lastContent = text; // Keep original text for diffing
                    positionCursor();
                    
                    if (!isComplete) {
                        updateStatus('Streaming in progress...');
                    }
                    
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error loading initial content:', error);
                return false;
            }
        }

        // Load new content from the text file
        async function loadNewContent() {
            if (isComplete) {
                clearInterval(checkInterval);
                return;
            }
            
            const txtUrl = window.location.href.replace(/\.html$/, '.txt') + '?t=' + Date.now();
            
            try {
                const response = await fetch(txtUrl, { 
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    if (lastContent.length === 0) {
                        updateStatus('Waiting for response to start...');
                    }
                    return;
                }
                
                const text = await response.text();
                
                if (text && text.length > lastContent.length) {
                    const newText = text.substring(lastContent.length);
                    const processedText = processContent(text);
                    
                    // If we've hit the completion marker, handle that
                    if (isComplete) {
                        contentDiv.textContent = processedText;
                        lastContent = text;
                        positionCursor();
                        return;
                    }
                    
                    // Only animate in the new text
                    lastContent = text;
                    
                    // Add new characters to the queue
                    const newChars = processedText.substring(contentDiv.textContent.length);
                    typeQueue.push(...newChars.split(''));
                    
                    // Start typing if not already typing
                    if (!isTyping && typeQueue.length > 0) {
                        isTyping = true;
                        typeCharacter();
                    }
                }
            } catch (error) {
                console.error('Error loading content:', error);
                if (lastContent.length === 0) {
                    updateStatus('Error loading response. Please try again.');
                }
            }
        }
        
        // Initialize
        async function init() {
            // Try to load existing content first
            const hasContent = await loadInitialContent();
            
            // If no content yet, start checking for updates
            if (!hasContent) {
                checkInterval = setInterval(loadNewContent, 500);
            } else {
                // If we have content, check for updates less frequently
                checkInterval = setInterval(loadNewContent, 2000);
            }
            
            // Set up event listeners
            window.addEventListener('resize', positionCursor);
            
            // Check if generation is complete by looking for a completion marker
            const checkCompletion = async () => {
                try {
                    const response = await fetch(window.location.href.replace(/\.html$/, '.complete'));
                    if (response.ok) {
                        isComplete = true;
                        clearInterval(checkInterval);
                        cancelBtn.disabled = true;
                        updateStatus('Generation complete');
                    }
                } catch (error) {
                    // Ignore errors
                }
            };
            
            // Check for completion every 5 seconds
            setInterval(checkCompletion, 5000);
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
